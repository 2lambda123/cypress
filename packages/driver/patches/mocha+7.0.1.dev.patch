diff --git a/node_modules/mocha/lib/mocha.js b/node_modules/mocha/lib/mocha.js
index 0b43004..588e195 100644
--- a/node_modules/mocha/lib/mocha.js
+++ b/node_modules/mocha/lib/mocha.js
@@ -853,7 +853,7 @@ Mocha.prototype.run = function(fn) {
   options.files = this.files;
   var runner = new exports.Runner(suite, options.delay);
   createStatsCollector(runner);
-  var reporter = new this._reporter(runner, options);
+  var reporter = this._reporter(runner, options);
   runner.checkLeaks = options.checkLeaks === true;
   runner.fullStackTrace = options.fullTrace;
   runner.asyncOnly = options.asyncOnly;
diff --git a/node_modules/mocha/lib/runner.js b/node_modules/mocha/lib/runner.js
index ceb1a24..0b8b9ba 100644
--- a/node_modules/mocha/lib/runner.js
+++ b/node_modules/mocha/lib/runner.js
@@ -677,23 +677,26 @@ Runner.prototype.runTests = function(suite, fn) {
           }
           self.emit(constants.EVENT_TEST_END, test);
           return self.hookUp(HOOK_TYPE_AFTER_EACH, next);
-        } else if (err) {
-          var retry = test.currentRetry();
-          if (retry < test.retries()) {
-            var clonedTest = test.clone();
-            clonedTest.currentRetry(retry + 1);
-            tests.unshift(clonedTest);
-
-            self.emit(constants.EVENT_TEST_RETRY, test, err);
-
-            // Early return + hook trigger so that it doesn't
-            // increment the count wrong
-            return self.hookUp(HOOK_TYPE_AFTER_EACH, next);
-          } else {
-            self.fail(test, err);
+        }
+        // TODO: refactor this
+        else {
+          const ret = self._onTestAttemptFinished({
+            test,
+            tests,
+            err,
+            next,
+            constants: {
+              ...constants,
+              HOOK_TYPE_AFTER_EACH,
+              STATE_PASSED,
+              STATE_FAILED,
+            },
+            runner: self,
+          })
+
+          if (ret !== false) {
+            return
           }
-          self.emit(constants.EVENT_TEST_END, test);
-          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);
         }
 
         test.state = STATE_PASSED;
