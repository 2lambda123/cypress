diff --git a/node_modules/mocha/lib/mocha.js b/node_modules/mocha/lib/mocha.js
index 0b43004..588e195 100644
--- a/node_modules/mocha/lib/mocha.js
+++ b/node_modules/mocha/lib/mocha.js
@@ -853,7 +853,7 @@ Mocha.prototype.run = function(fn) {
   options.files = this.files;
   var runner = new exports.Runner(suite, options.delay);
   createStatsCollector(runner);
-  var reporter = new this._reporter(runner, options);
+  var reporter = this._reporter(runner, options);
   runner.checkLeaks = options.checkLeaks === true;
   runner.fullStackTrace = options.fullTrace;
   runner.asyncOnly = options.asyncOnly;
diff --git a/node_modules/mocha/lib/runner.js b/node_modules/mocha/lib/runner.js
index ceb1a24..d04bb8e 100644
--- a/node_modules/mocha/lib/runner.js
+++ b/node_modules/mocha/lib/runner.js
@@ -677,9 +677,31 @@ Runner.prototype.runTests = function(suite, fn) {
           }
           self.emit(constants.EVENT_TEST_END, test);
           return self.hookUp(HOOK_TYPE_AFTER_EACH, next);
-        } else if (err) {
+        } 
+        else if (err || test.hasAttemptPassed) {
+          if(test.hasAttemptPassed){
+            // currently, to get attempts to work in cypress
+            // we signal to mocha that we need to try a test with the
+            // property hasAttemptPassed on the test
+            test.state = STATE_PASSED
+          } else {
+            // otherwise, we can assume the test failed
+            test.state = STATE_FAILED
+          }
+
+          // evaluate if the test should continue based on calculateTestStatus
+          // this is a custom method added by Cypress
+          // in ./driver/src/cypress/mocha.ts
+          const testStatusInfo = test.calculateTestStatus()
+
+          if(!testStatusInfo.shouldAttemptsContinue){
+            // if we are halting attempts, do NOT modify mocha _retries as it has side effects in the library
+            test._cypressTestStatusInfo = testStatusInfo
+          }
+
           var retry = test.currentRetry();
-          if (retry < test.retries()) {
+
+          if (retry < test.retries() && testStatusInfo.shouldAttemptsContinue) {
             var clonedTest = test.clone();
             clonedTest.currentRetry(retry + 1);
             tests.unshift(clonedTest);
@@ -689,8 +711,23 @@ Runner.prototype.runTests = function(suite, fn) {
             // Early return + hook trigger so that it doesn't
             // increment the count wrong
             return self.hookUp(HOOK_TYPE_AFTER_EACH, next);
-          } else {
-            self.fail(test, err);
+          // If this is the LAST test & the strategy is "detect-flake-and-pass-on-threshold" (or unset) & the test failed
+          // OR this is the LAST test & the strategy is "detect-flake-but-always-fail"
+          // & there is AT LEAST one failure (regardless of the current test status, A.K.A "Unreliable")
+          } else if(testStatusInfo.outerStatus === STATE_FAILED) {
+            // if the strategy is "detect-flake-but-always-fail", has an outer failed status, but the last test passed
+            // fail the test with the last error
+            if(test.state == STATE_PASSED){
+              const lastTestWithErr = (test.prevAttempts || []).find(t => t.state === STATE_FAILED)
+              // TODO: figure out serialization with this
+              // The OR statement here should be unreachable, but is intended for a fallback in case something is missed (especially under development)
+              err = lastTestWithErr?.err || new Error({ message: `expected test to have state "${testStatusInfo.outerStatus}" but was state "${test.state}".`})
+            }
+            self.fail(test, err)
+          } else if (testStatusInfo?.outerStatus === STATE_PASSED){
+            // there is no case where a test can 'pass' and the last test be a failure,
+            // meaing we can assume a 'passed' outerStatus has a final passed test
+            self.emit(constants.EVENT_TEST_PASS, test);
           }
           self.emit(constants.EVENT_TEST_END, test);
           return self.hookUp(HOOK_TYPE_AFTER_EACH, next);
@@ -1029,3 +1066,4 @@ Runner.constants = constants;
  * @external EventEmitter
  * @see {@link https://nodejs.org/api/events.html#events_class_eventemitter}
  */
+
